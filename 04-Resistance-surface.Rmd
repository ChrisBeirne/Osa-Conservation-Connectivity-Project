

```{r ch4_setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library("devtools")
#install_github("achubaty/grainscape")
library(grainscape)
library(raster)
library(ggplot2)
library(ggpubr)
library(stars)
library(sf)
library(leastcostpath)
library(gdistance)
library(kableExtra)
library(igraph)
library(nngeo)
library(dplyr)
library(leaflet)
library(terra)
library(elevatr)



# Import required data files

merged_shp <- st_read("data/input/area_of_interest/aoi.shp")
base_shp <- st_read("data/input/area_of_interest/base_aoi.shp", quiet = TRUE)
high_pa <- st_read("data/input/area_of_interest/high_elevation_pas.shp")
mangrove_large <- st_read("data/input/mangroves/mangrove_large_1kmsq.shp")
#plot(st_geometry(high_pa))
```

# Resistance surface {#cost-surface}

The most fundamental aspect of connectivity analyses is the 'resistance surface'. Resistance surfaces are spatially-explicit raster data layers that assign a resistance value to landscape features which in theory reflects the degree to which the feature in question impedes or facilitates movement. With a robust and rigorous resistance surface, functional connectivity across the landscape can be assessed. However, one of the biggest challenges in connectivity mapping remains the designation of specific resistance values to landscape features. See  Zeller et al. (2012) <https://link.springer.com/article/10.1007/s10980-019-00870-3>.


## Creating the resistance surface

For this approach to give meaningful and actionable output, we need to define resistance surfaces which reflect animal movement. We know that spatial scale is an important element of this - the higher the resolution of the map, the closer it can reflect reality. However, there exists a tradeoff, the higher the resolution, the higher the computational time. We will switch between scales depending on the the approach and the scale of inference we like. General, broad spatial scale analysis will be done at low resolution. When we want to study a specific location, we will do it in high resolution. 

See the reference below for consideration of spatial scale:

Hernando A, Velázquez J, Valbuena R, et al (2017) Influence of the resolution of forest cover maps in evaluating fragmentation and connectivity to assess habitat conservation status. Ecol Indic 79:295–302. https://doi.org/10.1016/j.ecolind.2017.04.031

The first step in the analysis is to simplify the total focal area to 10 priority landscapes - we simply want to quantify the distance to and relative disturbance along the route, of low elevation to high elevation areas. To do this we use a computationally rapid, least-costs paths approach (see Chapter 4 for a description). The backbone of this approach uses the human modification index, which represents a proxy for the structural connectivity across the focal landscapes, modified by whether the area is protected or not, and weather it has (on average) forest cover.

The basis of this approach is the human modification index layer, which we have invert so that high values = low disturbance (green), and low values = high disturbance (orange/white):

### Step 1: High resolution landcover {#cost-surface_high}
Although we have a 10m landcover layer available to us, it will take weeks to run connecivity analyses across the whole AOI at that resolution. Consequently, I am presenting a raster which has been reduced by a factor of ten in every direction (x and y) resulting in a 100m resolution.

After the prioritization steps in [the least-cost-path chapter](#lcp), we will take a subset of these candidate locations and explore them in high resolution. The high resolution map is created in the same was as the coarse scale map (above), however at a finer grain (100m vs. 1km) with land-use and habitat quality accounted for. The high resolution maps leans heavily on the land cover map of Central America created by ESA.

In order to conceptulize the resistance of each of these layers it is important to understand their definitions [See this link for full details and validation](https://2018mexicolandcover10m.esa.int/documents/ESACCI_CCN2_PVIRv0.3.pdf):

**Tree cover**: Area with a **tree canopy cover of more than 15%** of the surface and higher
than the shrub cover and the herbaceous cover. A tree is a woody perennial
plant with a single, well-defined stem carrying a more-or-less defined crown (Ford-Robertson, 1971) and being at least 3m tall. Snow and/or ice, open water or built-up areas cover less than 50% of the surface.

**Shrub cover**: area with an **herbaceous cover of more than 15% of the surface and dominant with regards to the other vegetation types (higher canopy cover than the tree cover or the shrub cover)**. Herbaceous plants are defined as plants without persistent stem or shoots above ground and lacking definite firm structure (Scoggan, 1978).

**Crop land**: The cropland corresponds to the annual cropland which is defined as a piece of **land (> 50% of the surface) that is sowed/planted and harvestable at least once within the 12 months after the sowing/planting date.** The annual cropland produces a herbaceous cover and is sometimes combined with some tree or woody vegetation (less than 20% canopy cover). This definition is an adaptation of the ‘JECAM annual cropland class from a remote sensing perspective’
definition (JECAM, 2014).

**Sparce vegetation**: The area where the sum of all vegetation canopy cover is less than 15%.

**Grassland**: The area with an herbaceous cover of more than 15% of the surface and
dominant with regards to the other vegetation types (higher canopy cover than
the tree cover or the shrub cover). Herbaceous plants are defined as plants
without persistent stem or shoots above ground and lacking definite firm
structure (Scoggan, 1978). Snow and/or ice, open water or built-up areas cover
less than 50% of the surface.

**Bare areas**: Areas where the sum of all vegetation canopy cover is less than 4%. Included are
bare rock areas, sands and deserts.

**Built-up areas**: The class is composed of any type of areas with a predominant artificial surface
(> 50%): buildings, roads, airports, etc. The class also includes industrial areas,
waste dump deposit and extraction sites.

We can then integrate this high resolution land use map with other layers of interest to generate our cost surface.

The following is a down-scaled map of the whole survey area. 

```{r ch4_8new, echo=F, message=F, warning=F, eval=F}
# New method
lc <- rast("data/input/landcover/ESACCI-global-10m_merged.tif")

# Reduce res - by factor of 10
lc_100m <- aggregate(lc, fact=10, fun="modal")

lc_key <- read.csv("data/input/landcover/ESA_v2_labels.csv", header=T, sep=",")
lc_key$rgb <- paste0("#",lc_key$rgb ) 
coltab(lc_100m)  <- data.frame(value=lc_key$NB_LAB, col=lc_key$rgb)
plot(lc)
#plot(lc_100m)
writeRaster(lc_100m, "data/input/landcover/ESACCI-global-100m_merged.tif", overwrite=T)

```

```{r}
lc_100m <- rast("data/input/landcover/ESACCI-global-100m_merged.tif")

lc_key <- read.csv("data/input/landcover/ESA_v2_labels.csv", header=T, sep=",")
lc_key$rgb <- paste0("#",lc_key$rgb ) 

# Remove no data
#lc_key <- lc_key[1:11,]
# Simplify labels
plot(lc_100m, legend=T, key.pos=NULL)
legend("topright",legend=lc_key$LCCOwnLabel, fill=lc_key$rgb)
```

Lets zoom in and explore a location we know well.

#### Interactive map

```{r ch4_9, echo=F, message=F, warning=F}
#Subset to just osa xmin, x max, ymin, ymax
aoi <-  ext(-84, -82.5,8.38,9.38)
lc_sub  <- terra::crop(lc_100m, aoi)
#plot(lc_sub)

# Convert to a raster
lc_sub <- as(lc_sub,"Raster")
colours <- lc_key$rgb
# Plot it in leaflet
at <- c(5,15,25,35,45,55,65,75,85,94,96,101)
cb <- colorBin(palette = colours, bins = at, domain = at)

leaflet() %>%
    addProviderTiles("OpenStreetMap", group="OSM (default)") %>%
    addProviderTiles("Esri.WorldImagery", group="Satellite") %>%
    addRasterImage(lc_sub, colors = cb, group="Raster") %>%
    addLegend(colors = lc_key$rgb, labels=lc_key$LCCOwnLabel)%>% 
  addLayersControl(
    baseGroups = c("OSM (default)", "Satellite"),
    overlayGroups = c("Raster")) 

# Dowload elevation data too
elevation <- get_elev_raster(lc_sub, z = 11)
elevation[elevation<0]<- -100
raster_utm <- projectRaster(elevation, crs=31971)


writeRaster(elevation, "Data/output/Chapter6/Case_study_1_Osa/elevation.tif", overwrite=TRUE)
writeRaster(raster_utm, "Data/output/Chapter6/Case_study_1_Osa/elevation_utm.tif", overwrite=TRUE)


```

It works pretty well! But you can see that the main issue is that forest **quality** is not accounted for. The green area encompasses all sorts, from high biomass nice forest to plantations. 

**REVIEW QUESTION** how shall we account for forest quality? We could use the human modification index? Maybe the tree height layer... lets see how they look. One inescapable issue is that they are likely to be at a different resolution to the landcover data. 

#### Adjusting forest conductance

We can potentially account for forest quality using a suite of different layers: The human modification layer, forest height, forest biomass and forest cover. Below we can explore those options.  

```{r ch4_10, echo=F, eval=F}
# Only run first time
# Download a high res hansen map
#py_install("numpy")

ee_Initialize()
# Check things are working
ee_check()
# Second text
reticulate::py_config()
aoi_gee  <-  ext(-84, 8.38, -82.5,9.38)
focal <- ee$Geometry$Rectangle(as.numeric(st_bbox(aoi_gee)))

gfc <- ee$Image("UMD/hansen/global_forest_change_2021_v1_9")
Map$addLayer(
    eeObject = gfc,
    visParams = list(
      bands = c('treecover2000'),
      min = 0,
      max = 100,
      palette = c('white','green')),
    name = 'Forest cover')


# Map$addLayer(
#     eeObject = gfc,
#     visParams = list(
#       bands = c('loss'),
#       min = 0,
#       max = 1,
#       palette = c('white','red')),
#     name = 'Forest cover')


loss <- gfc$select("loss")
notLoss <- (loss[["loss"]] *(-1)) +1

gfc_remain <- gfc$updateMask(notLoss)

Map$addLayer(
    eeObject = gfc_remain,
    visParams = list(
      bands = c('treecover2000'),
      min = 0,
      max = 100,
      palette = c('white','green')),
    name = 'Forest cover')

geom_params <-   list(
  scale = 30,
  crs = 'EPSG:4326',
  region = '[[-84 , 8.38], [-82.5, 8.38], [-82.5, 9.38], [-84 , 9.38]]'
  #region = focal
)

geometry <- ee$Geometry$Rectangle(
  coords = c(-84, 8.38, -82.5,9.38),
  proj = "EPSG:4326",
  geodesic = FALSE
)
#path <- gfc_remain[["treecover2000"]]$getDownloadUrl(geom_params)

ee_as_raster(gfc_remain[["treecover2000"]], region=geometry, maxPixels = 10000000000, scale=30)

```

The map below has stacked several rasters in order to directly compare them. 

**Human modification**: 1km resolution, data collected 2016

**Forest height**: 927m resolution, data collect 2005, published 2011

**Biomass**: 300m resolution, data collected 2010, published 2020

**Forest cover**: 30m, collected 2021, published 2022 

Use the menu contained in the white box to view the different data layers. 

```{r ch4_11, echo=F, message=F, warning=F}
fh <- rast("data/input/height/global_forest_canopy_height_2005.1.tif")
fh_sub  <- crop(fh, aoi)
fh_sub_ras  <- as(fh_sub,"Raster")

ghm <- rast("data/input/human_modification_index/gHM_2016.tif")
ghm_sub  <- crop(ghm, aoi)
ghm_sub_ras  <- as(ghm_sub,"Raster")
# Invert it so it plot the same as forest height
ghm_sub_ras <- ghm_sub_ras*-1

biomass <- rast("data/input/biomass/NASA_biomass_desnity_estimation.tif")
biomass_sub  <- crop(biomass, aoi)
biomass_sub_ras  <- as(biomass_sub,"Raster")

gfc <- rast("data/input/gfc/global_forest_change_2021_v1_9.treecover2000_Osa.tif")
#gfc_new <- rast("data/input/gfc/global_forest_change_2021_v1_9_2022_OSA.tif")

gfc_sub  <- crop(gfc, aoi)
biomass_sub_ras  <- as(biomass_sub,"Raster")

lc_sub_ter  <- terra::crop(lc_100m, aoi)

gfc_100 <- terra::resample(gfc_sub, lc_sub_ter)

#plot(gfc_100)
# Subsample to same resolution as the 

gfc_sub_ras  <- as(gfc_100,"Raster")

leaflet() %>%
    addProviderTiles("OpenStreetMap", group="OSM (default)") %>%
    addProviderTiles("Esri.WorldImagery", group="Satellite") %>%
    addRasterImage(lc_sub, colors = cb, group="lc") %>%
    addRasterImage(fh_sub_ras, group="Forest height") %>%
    addRasterImage(ghm_sub_ras, group="Human modification") %>%
    addRasterImage(biomass_sub_ras, group="Biomass") %>%
    addRasterImage(gfc_sub_ras, group="GFC") %>%
    
    addLayersControl(
    baseGroups = c("OSM (default)", "Satellite"),
    overlayGroups = c("lc", "Forest height","Human modification", "Biomass", "GFC")) 



```

*Summary of potential modifiers*

Exploring the layers above we can make some general conclusions:

- The human modification is mainly a copy of the landcover layer, so that will not be an effective forest quality modifer

- Forest height looks useful but it is at a very coarse scale. It is effectively the mean forest height over the cell, so it would account for "patch size" and isolation indirectly. But much better than the simple forest/non-forest layer.

- The global forest cover dataset, despite being a higher resolution than the other layers, does not appear very good at discriminating forest quality. 

- The biomass looks effective, and it is more recent than the forest height layer. 

In conclusion, we will use biomass as the moderator for forest quality.The way we incorporate it is to create a raster whereby biomass scales linearly from 0-1 between 0 and 100 Mg C/ha, and all values >100 Mg C/ha are also denoted as 1. We then take the product of the conductance layer with the scaled biomass layer, to give a final conductance surface which weights high quality (high biomass) forest as highly conductive to animal movement.     


## High resolution raster re-classification

Now that we have a high resolution habitat map (accounting for forest quality), we need to turn that into a "conductance surface". This means assigning values which relate the habitat to the probability of animal movement within and between it. 

Using traditional approaches this took a huge amount of computational time. However, we found a work around using the 'terra' package in R. This package uses clever computing to reduce the memory load of large rasters making high resolution mapping in R more scale-able. For our re-classification scheme we will use the following formula, based on work from other publications. The values should be viewed as the probability of use e.g. 1000 = very high probability of movement, 1 = very low:

- No data:                  0   -> NA
- Tree cover:               10  -> 1000 [The best, will moderate with the tree height layer to account for quality] 
- Shrub cover:              20  -> 150 [some cover - mianly seems to be forest margins]
- Grassland:                30  -> 30  [Pasture]  
- Cropland:                 40  -> 30 [May have canopy cover, risky]
- Built up areas:           50  -> NA [Urban areas are excluded as they have no functional connectivity]
- Bare / sparse vegetation: 60  -> 40 [Risky but useable]
- Snow and/or Ice:          70  -> NA
- Open Water:               80  -> 30 [Very low conductivity -> last resort (100m resolution will represent large water 
- Herbaceous wetland:       90  -> 20 [hard to move through]
- Mangroves                 95  -> 500 [Probably not used]
- Moss and lichen:          100 -> 2 Dont exist on thsi landscpe


### High resolution case study: Osa

Zooming in to a specific landscape allows us to map connectivity at much higher resolution. We will ultimately do this for all of the focal landscapes defined, however here we present a single example to check that the high resolution resistance classification scored defined above are reasonable.

Below is the high resolution 'resistance to movement' map for the Osa Pennisula. Red areas denote areas with high resistance to movement whereas blue areas denote zones with very low resistance.  

```{r  ch4_11a, echo=F, message=F, warning=F}
m2     <- c(0, NA,
            10, 1000,
            20, 150,
            30, 30,
            40, 30,
            50, NA,
            60, 40,
            70, NA,
            80, 30,
            90, 20,
            95, 500,
            100,2
            )
m2 <- matrix(m2, ncol=2, byrow = TRUE)

# workflow

  #Import the raster
  
  #Reclassify according to my values

  # Then split out rasters for each habitat type and moderate them.

  # Merge for final raster

library(terra)
lc <- rast("data/input/landcover/ESACCI-global-100m_merged.tif")

#Subset to just osa xmin, x max, ymin, ymax
aoi <-  ext(-84, -82.5,8.38,9.38)
lc_sub  <- crop(lc, aoi)

# Reclassify the full thing?
lc_re <- classify(lc_sub, m2, right=TRUE)

# Downscale to 100m resolution
#lc_re_small <- aggregate(lc_re, fact=10, fun="modal")
#lc_re_small <- aggregate(lc_re, fact=10, fun="mean")

lc_re_small_ras <- as(lc_re,"Raster")
#plot(lc_re_small_ras)
```


```{r  ch4_14, echo=F, message=F, warning=F, include=F}

# Add the biomass modifier
biomass_sub <- clamp(biomass_sub, upper=100)
#plot(biomass_sub)
biomass_modifier <- biomass_sub/100
plot(biomass_modifier)
```

```{r  ch4_15, echo=F, message=F, warning=F, include=F}

#We then mask out non-forest areas, and apply the modifier, which creates a surface which looks like:

just_forest <- ifel(lc_sub == 10, 1, NA)

#plot(just_forest)
# Match the resolutions
biomass_modifier <-  resample(biomass_modifier, just_forest)
#plot(biomass_modifier)
#plot(just_forest,add=T)

# Keep non-forest areas the same too!                      
final_modifier <- mask(biomass_modifier,just_forest)
# Keep none forest as they are
final_modifier <- subst(final_modifier, NA, 1)

```

The map shows two layers the 'original' and the 'modified' (after accounting for biomass). Use the menu in the top right to toggle them on and off. 

```{r  ch4_16, echo=F, message=F, warning=F}
# Apply the modifier
cost_final <- lc_re*final_modifier
#plot(cost_final)

lc_100m <- rast("data/input/landcover/ESACCI-global-100m_merged.tif")
base_terra <- vect(base_shp)

# First mask the outline then do large waterbodies 
cost_final  <-mask(cost_final,base_terra)

# Mask out large water bodies
cond_1km<- raster("Data/output/Chapter5/Low_res_resistance_surface.tif")
#plot(cond_1km)
cond_1km[cond_1km>0]<-1
#plot(cond_1km)
tmp <- rast(cond_1km)
tmp <- as.polygons(tmp)
tmp <- project(tmp,cost_final )
#plot(tmp)
cost_final  <-mask(cost_final, tmp)


cost_final_ras <- as(cost_final,"Raster")

leaflet() %>%
  addProviderTiles("OpenStreetMap", group="OSM (default)") %>%
  addProviderTiles("Esri.WorldImagery", group="Satellite") %>%
  addRasterImage(lc_re_small_ras, group="Original") %>%
  addRasterImage(cost_final_ras, group="Modified") %>%
  addLayersControl(
    baseGroups = c("OSM (default)", "Satellite"),
    overlayGroups = c("Original", "Modified")) 


dir.create("Data/output/Chapter6/Case_study_1_Osa/")

writeRaster(cost_final_ras, "Data/output/Chapter6/Case_study_1_Osa/cellmap.asc", overwrite=TRUE, gdal="DECIMAL_PRECISION=0", NAflag=-9999)

writeRaster(cost_final_ras, "Data/output/Chapter6/Case_study_1_Osa/cost_surface_100m.tif", overwrite=TRUE)

```

These resistance surfaces are used in subsequent chapters to perform the connectivity analyses.

## High resolution layer for least cost models

Using the same parameters as above to create a conductance surface across the whole AOI. I have produced 1km, 200m and 100m versions. 

```{r, echo=F, include=F, warning=F, message=F, eval=F}
library(terra)
lc_100m <- rast("data/input/landcover/ESACCI-global-100m_merged.tif")
base_terra <- vect(base_shp)
lc_key <- read.csv("data/input/landcover/ESA_v2_labels.csv", header=T, sep=",")
lc_key$rgb <- paste0("#",lc_key$rgb ) 
lc_100m <- mask(lc_100m, base_terra)
# Remove no data
#lc_key <- lc_key[1:11,]
# Simplify labels
#plot(lc_100m, legend=T, key.pos=NULL)
#legend("topright",legend=lc_key$LCCOwnLabel, fill=lc_key$rgb)
```


```{r  ch4_11b, echo=F, message=F, warning=F, include=F, eval=F}
# Reclassify the full thing?
lc_re <- classify(lc_100m, m2, right=TRUE)
lc_re_ras <- as(lc_re,"Raster")
plot(lc_re_ras)

```


```{r  ch4_14b, echo=F, message=F, warning=F, include=F, eval=F}
biomass <- clamp(biomass, upper=100)
#plot(biomass)
biomass_modifier <- biomass/100
plot(biomass_modifier)
```

```{r  ch4_15b, echo=F, message=F, warning=F, include=F, eval=F}

#We then mask out non-forest areas, and apply the modifier, which creates a surface which looks like:

just_forest <- ifel(lc_100m == 10, 1, NA)

#plot(just_forest)
# Match the resolutions
biomass_modifier <-  resample(biomass_modifier, just_forest)
#plot(biomass_modifier)
#plot(just_forest,add=T)

# Keep non-forest areas the same too!                      
final_modifier <- mask(biomass_modifier,just_forest)
# Keep none forest as they are -> 1 (as we ultimately take the prodict)
final_modifier <- subst(final_modifier, NA, 1)


```

```{r  ch4_16b, echo=F, message=F, warning=F, eval=F}
cost_final <- lc_re*final_modifier


# Mask out large water bodies - use the archived conducatnce layer
cond_1km<- raster("Data/output/Chapter5/Low_res_resistance_surface.tif")
#plot(cond_1km)
cond_1km[cond_1km>0]<-1
#plot(cond_1km)
tmp <- rast(cond_1km)
tmp <- as.polygons(tmp)
tmp <- project(tmp,cost_final )
#plot(tmp)
cost_final  <-mask(cost_final, tmp)
#plot(cost_final)
#cost_final_ras <- as(cost_final,"Raster")


#########################################
# 100m Resoltuion #######################
#########################################

writeRaster(cost_final, "Data/output/Chapter5/High_res_resistance_surface_final.tif", overwrite=T)

# Make a 17N version
cost_final<- rast("Data/output/Chapter5/High_res_resistance_surface_final.tif")
tmp <- project(cost_final, "+proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs")

# Also make a version with NA's removed (required for least cost path models)
tmp2 <- classify(tmp, cbind(NA, 0.000001))
tmp <- as(tmp,"Raster")
tmp2 <- as(tmp2,"Raster")

writeRaster(tmp, "Data/output/Chapter5/High_res_resistance_surface_final_17N.tif", overwrite=T)
writeRaster(tmp2, "Data/output/Chapter5/High_res_resistance_surface_final_17N_NO_NA.tif", overwrite=T)

#########################################
# 1km resolution ########################
#########################################
# Make  1km version too 

cost_final <- rast("Data/output/Chapter5/High_res_resistance_surface_final.tif")
cost_final_17N <- rast("Data/output/Chapter5/High_res_resistance_surface_final_17N.tif")
cost_final_17N_NO_NA <- rast("Data/output/Chapter5/High_res_resistance_surface_final_17N_NO_NA.tif")

# Added na.rm=T -> so the missing data doesnt negate the whole pixel
cost_final_1km <- aggregate(cost_final, fact=10, fun="mean", na.rm=T)
writeRaster(cost_final_1km, "Data/output/Chapter5/Low_res_resistance_surface_final.tif", overwrite=T)

cost_final_1km_17N <- aggregate(cost_final_17N, fact=10, fun="mean", na.rm=T)
writeRaster(cost_final_1km_17N, "Data/output/Chapter5/Low_res_resistance_surface_final_17N.tif", overwrite=T)

cost_final_1km_17N_NO_NA <- aggregate(cost_final_17N_NO_NA, fact=10, fun="mean", na.rm=T)
writeRaster(cost_final_1km_17N_NO_NA, "Data/output/Chapter5/Low_res_resistance_surface_final_NO_NA_17N.tif", overwrite=T)

#########################################
# 200m resolution ########################
#########################################
# Make  a 200m version incase 100m is too slow

# Added na.rm=T -> so the missing data doesnt negate the whole pixel
cost_final_200m <- aggregate(cost_final, fact=2, fun="mean", na.rm=T)
writeRaster(cost_final_200m, "Data/output/Chapter5/Mid_res_resistance_surface_final.tif", overwrite=T)

cost_final_200m_17N <- aggregate(cost_final_17N, fact=2, fun="mean", na.rm=T)
writeRaster(cost_final_200m_17N, "Data/output/Chapter5/Mid_res_resistance_surface_final_17N.tif", overwrite=T)

cost_final_200m_17N_NO_NA <- aggregate(cost_final_17N_NO_NA, fact=2, fun="mean", na.rm=T)
writeRaster(cost_final_200m_17N_NO_NA, "Data/output/Chapter5/Mid_res_resistance_surface_final_17N_NO_NA.tif", overwrite=T)

cost_final_ras <- as(cost_final_1km,"Raster")

leaflet() %>%
  addProviderTiles("OpenStreetMap", group="OSM (default)") %>%
  addProviderTiles("Esri.WorldImagery", group="Satellite") %>%
  addRasterImage(cond_1km, group="Original") %>%
  addRasterImage(cost_final_ras, group="Modified") %>%
  addLayersControl(
    baseGroups = c("OSM (default)", "Satellite"),
    overlayGroups = c("Original", "Modified"))

```

```{r, message=F, warning=F, echo=F}
cost_final_1km <- raster("Data/output/Chapter5/Low_res_resistance_surface_final.tif")

cost_final_ras <- as(cost_final_1km,"Raster")

leaflet() %>%
  addProviderTiles("OpenStreetMap", group="OSM (default)") %>%
  addProviderTiles("Esri.WorldImagery", group="Satellite") %>%
  addRasterImage(cost_final_ras, group="Modified") %>%
  addLayersControl(
    baseGroups = c("OSM (default)", "Satellite"))

```




